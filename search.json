[
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "Harvey Mudd College E155 Course Website"
  },
  {
    "objectID": "proposal.html",
    "href": "proposal.html",
    "title": "Project Proposal",
    "section": "",
    "text": "Julia Gong and Georgia Tai"
  },
  {
    "objectID": "proposal.html#project-description",
    "href": "proposal.html#project-description",
    "title": "Project Proposal",
    "section": "Project Description",
    "text": "Project Description\nThis project aims to take in sound inputs, whether using a keyboard, any instruments, or someone signing, transcribe the sound onto a score in real-time with a given bpm, and play back the input melody. An FPGA will be used as the main calculation and display engine, using Fast Fourier Transform (FFT) to handle frequency analysis and driving a VGA display. A MCU will be used for interfacing the audio inputs and outputs.\nOn the hardware level, an analog microphone will take in sounds, where the MCU will convert them into digital signals using ADC and send the converted signals to the FPGA. The MCU will then send the digital signals to the FPGA using SPI. Then, the FPGA will use FFT to extract the frequency and duration of the note inputted. The array of notes will then be used by the FPGA to calculate the pixels for displaying the score on a VGA display. This array of notes, after transcription ends, will be sent to the MCU through SPI to generate the playback audio. The user should be able to control the music transcription and play back audio with a hardware components such as a switch or a button, and control the volume with a potentiometer.\n\n\n\nThis image shows the block diagram of the music transcriber system."
  },
  {
    "objectID": "proposal.html#project-specifications",
    "href": "proposal.html#project-specifications",
    "title": "Project Proposal",
    "section": "Project Specifications",
    "text": "Project Specifications\n\nInput: detection and analysis\n\nUser can stop and start transcription using physical hardware (e.g. switch/button)\nSystem converts analog microphone signals into digital\nUses FFT to extract clear signal from input\nCalculates frequency and duration of inputs accurately\n\n\n\nOutput: display and audio\n\nDisplay updates at &gt; 24 Hz\nNotes display in real time\nNote durations are displayed for 120 bpm\nPlayback audio resembles the input\nPlayback audio uses an audio codec so that output sound is not square wave\nUser can control the volume of playback audio\nUser can control when to playback the transcribed audio (e.g. switch/button), but can only play the audio when transcription is stopped"
  },
  {
    "objectID": "proposal.html#design-overview",
    "href": "proposal.html#design-overview",
    "title": "Project Proposal",
    "section": "Design Overview",
    "text": "Design Overview\nThe input signals from the microphone remain the riskiest element of the system. To improve the microphone input detection, the Maxim MAX4466 was chosen since it has a built in amplifier with a maximum adjustable gain of x125.\n\nFPGA: UPDuino v3.1 (iCE40UP5K)\n\nFFT & Pitch Detection - A 512-point FFT will be run by the FPGA to extract dominant frequencies from the digital audio samples sent from the MCU over SPI. The results will be stored in SPRAM.\nDuration Detection - The FPGA will count the FFT frames of a specific note and convert the count using the current BPM to infer duration of a note. The array of note events will also be stored in SPRAM.\nVGA Controller - VGA timing signals and framebuffer data extracted from SPRAM will be used to compose the score on a VGA screen in real time.\nSPI Peripheral - This provides the FPGA as an SPI interface which the MCU can read and write to, bridging the connection between the two.\n\n\n\nMCU: STM32L432KC\n\nADC - The microphone specifies to connect its output to the ADC pin. This will allow the MCU to buffer the samples and convert our desired input in to digital signals.\nI2S - This will allow the MCU to synthesize the audio for playback and send it to the audio codec, where the audio codec we chose to use expects I2S.\nControl - The MCU will handle user commands, reading buttons/switches for the start/end of transcription or playback and potentiometer for the volume of the playback audio.\nSPI Controller - The MCU will act as the SPI controller to send digital sound inputs to the FPGA and to receive the transcribed note array when transcription stops."
  },
  {
    "objectID": "proposal.html#calculations",
    "href": "proposal.html#calculations",
    "title": "Project Proposal",
    "section": "Calculations",
    "text": "Calculations\n\nFast Fourier Transform Calculations\nThe Fast Fourier Transform transforms a signal from the time to frequency domain by recursively dividing a discrete fourier transform (DFT) into its odd and even indexed elements. The odd and even DFTs are of size N/2, where N is the size of its non-spit DFT. Using the symmetry and periodicity properties of complex exponentials, the even part corresponds to a half sized DFT and odd part corresponds to a half sized DFT that is multiplied by the twiddle factor (which is complex exponential expressed by \\(W_N\\)).\nThese equations below show the DFT and how the DFT can be split into its even and odd components.\nDFT equation: \\[\nX[k] = \\sum_{n=0}^{N-1} x[n] W_N^{kn}\n\\] DFT equation split into even and odd components: \\[\nX[k]  = \\sum_{m=0}^{\\frac{N}{2}-1} x[2m] W_N^{k(2m)}\n+ \\sum_{m=0}^{\\frac{N}{2}-1} x[2m+1] W_N^{k(2m+1)}\n\\] where \\[\nW_N = e^{-j \\frac{2\\pi}{N}}\n\\]\nUsing Radix-2 decompositions, an N point FFT can be computed through:\n\n\\(\\log_2(N)\\) levels of transforms\nEach transform has \\(N/2\\) butterfly operations\nA total of \\(\\frac{N}{2} \\log_2(N)\\) butterfly operations\n\nWe decided to use a 512 point FFT for higher resolution processing of our microphone inputs. Since N = 512, we would require:\n\n\\(\\log_2(512) = 9\\) levels of transforms\n\\(512/2 = 256\\) butterfly operations\ntotal of \\(\\frac{512}{2} \\log_2(512) = 2304\\) butterfly operations\n\nTo calculate the amount of FPGA Block RAM used, each complex sample and twiddle factor contains 4 bytes (16 bits each for real and imaginary). There are a total of 512 complex samples and 256 twiddle factors.\nTotal number of bytes used: (512 x 4) + (256 x 4) = 3072 bytes or 3kB\nEach butterfly operation takes in two complex inputs (ex A and B), multiplies B by the twiddle factor, and adds/subtract. Four multiplications will be needed in hardware, which will be handled by 4 DSPs. A butterfly operation will required an approximated 300 LUTs (16 each for add/subtract, 32 each for complex add/subtract, 40 for multiply overhead when using DSPs, 40 for twiddle address, 100 for pipelined registers). An approximated LUTs are used for the FFT controller 400.\nThe number of LUTs required for a 512 point FFT with 2 pipelined butterfly operations can be calculated by:\n\\[\n\\text{Total LUTs} = (\\text{LUTs per butterfly}) \\times (\\text{\\# of pipelined butterflies}) + \\text{LUTs for controller}\n\\]\n\\[\n\\text{Total LUTs} = 300 \\times 2 + 400 = 1000 \\text{ LUTs}\n\\]\nIn order to calculate the duration of the notes using FFTs, two overlapping FFTs will be used. Using overlapping FFTs will ensure that input signals will be captured. The FPGA will check for new note activity after every FFT is computer to detect the start and stop of notes. The amount of FFT frames for a note can then be converted to note duration. The FFT frame length will depend on the MCU ADC sampling rate.\nUsing 2 overlapping FFTs will doule the amount of memory and LUTs used. The FFT computation will require approximately 6kB of block RAM and 2000 LUTs.\n\n\nVGA Calculations\nSuppose that we use a VGA screen of 640x480 @ 60 Hz, which normally has 800 pixels per line and 525 lines per frame, we can calculate the clock timing by:\n\\[\n\\text{Pixel clock} = (\\text{pixels per line}) \\times (\\text{lines per frame}) \\times \\text{frames per second}\n\\]\n\\[\n\\text{Pixel clock} = 800 \\times 525 \\times 60 = 25.2 \\text{ MHz}\n\\]\nThe visible pixels per frame is: \\[\n\\text{number of pixels} = 640 \\times 480 = 307200 \\text{ pixels}\n\\]\nIn the case which scores and notes can be drawn with just black and white, we only need one bpp for each pixel. The memory required is thus 307200 bits, or 38.4 kB.\nGiven that the UPDuino v3.1 has a SPRAM of 128 kB, the estimated memory used by FFT (6 kB) and by VGA (~40 kB), can easily fit within.\nAs for the estimated LUTs, the VGA controller should mainly be composed of counters (to keep tract of the pixels), pixel address calculator, framebuffer reader, RGB output mapping, and FSM control. The counters should each be around 10 bits (for 800 pixels per line and 525 lines), which gives around 10 LUTs for each of the horizontal and vertical counters. The address generator will need to compute both constant multiplication and addition, which will result in ~50 LUTs for considering 10 bits for both counters previously mentioned. The framebuffer reader may take 100 LUTs to read the address, construct a read control FSM, shift pixels, and buffer the frames if needed. The RGB output mapping will most likely need ~20 LUTs to check if a pixel is visible and the value of each of the three colors. Around 50 LUTs are estimated for the FSM control logic, which will handle the synchronization and mode logic of the VGA display.\nThe total estimated LUTs for the VGA thus adds up to at least 250 LUTs. Our estimated LUTs for the FFT control is about 2000. Given that there are 5k available LUTs on the FPGA, we should have a reasonable amount of space to modify and complex our design, for example adding more buffers to the VGA display."
  },
  {
    "objectID": "proposal.html#proposed-timeline-and-work-distribution",
    "href": "proposal.html#proposed-timeline-and-work-distribution",
    "title": "Project Proposal",
    "section": "Proposed Timeline and Work Distribution",
    "text": "Proposed Timeline and Work Distribution\n\nProposed Timeline of Project\n\n\n\n\n\n\n\n\n\n\nWeek\nMonday Date\nTask\nTime\nPeople\nNotes\n\n\n\n\n1\n10/27\nDesign FFT hardware on FGPA\n15hr+\n\n\n\n\n\n\nWorking microphone and SPI between FPGA & MCU\n8hr+\n\n\n\n\n2\n11/3\nVGA implementation: setting score interface, able to display notes (no input dependencies)\n15hr+\n\n\n\n\n\n\nPrepare design review presentation\n2hr+\nBoth\n11/4-6: Design Review Presentation\n\n\n3\n11/10\nConnecting input and VGA, allowing notes obtained by FFT to display on screen\n10hr+\n\n\n\n\n4\n11/17\nPrepare for project status report and demo\n2hr+\nBoth\n11/18: Project status report & demo\n\n\n\n\nContinuing to debug real time note display on VGA\n15hr+\n\n\n\n\n\n\nImplementing duration detection for different bpms\n7hr+\n\nLess priority, if time allows\n\n\n5\n11/24\nIntegrating playback audio using SPI communication, audio codec, and speaker\n8hr+\n\n11/26-30: Thanksgiving break\n\n\n6\n12/1\nDebugging integration/system in general\n10hr+\nBoth\n\n\n\n\n\nPrepare for Final Checkoff (e.g. write-up)\n6hr+\nBoth\n12/2-4: Final Check-off\n\n\n\n\nPrepare for Demo Day\n3hr+\nBoth\n12/5: Demo Day"
  },
  {
    "objectID": "proposal.html#bill-of-materials",
    "href": "proposal.html#bill-of-materials",
    "title": "Project Proposal",
    "section": "Bill of Materials",
    "text": "Bill of Materials\n\n\n\n\n\n\n\n\n\n\nName\nPart #\nManufacturer\nQuantity\nPrice\n\n\n\n\nMicrophone\nMAX4466\nAdafruit\nx1\n$6.95\n\n\nAudio Codec\nMAX98357A\nAdafruit\nx1\n$5.95\n\n\nVGA Breakout Cord\n3124\nAdafruit\nx1\n$4.50\n\n\nVGA Display\n\n\nx1\nstockroom\n\n\nOp-amp\nMCP601\n\nx1\nstockroom\n\n\nPotentiometer\n\n\nx1\nstockroom\n\n\nSpeaker\n\n\nx1\nstockroom\n\n\nSTM32L432KC Microcontroller\n\nSTMicroelectronics\nx1\nE155 teaching team\n\n\nUPDuino v3.1 ICE40 UP5K FPGA\n\ntinyVision.ai\nx1\nE155 teaching team\n\n\n\n\n\nTotal including shipping + tax\n$31.66 (shipping $12.56 & tax $1.70)"
  }
]