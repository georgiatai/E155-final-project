[
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "Harvey Mudd College E155 Course Website"
  },
  {
    "objectID": "labs.html#lab-2-multiplexed-7-segment-display",
    "href": "labs.html#lab-2-multiplexed-7-segment-display",
    "title": "Labs",
    "section": "Lab 2: Multiplexed 7-Segment Display",
    "text": "Lab 2: Multiplexed 7-Segment Display"
  },
  {
    "objectID": "labs.html#lab-3-keypad-scanner",
    "href": "labs.html#lab-3-keypad-scanner",
    "title": "Labs",
    "section": "Lab 3: Keypad Scanner",
    "text": "Lab 3: Keypad Scanner"
  },
  {
    "objectID": "labs.html#lab-4-digital-audio",
    "href": "labs.html#lab-4-digital-audio",
    "title": "Labs",
    "section": "Lab 4: Digital Audio",
    "text": "Lab 4: Digital Audio"
  },
  {
    "objectID": "labs.html#lab-5-interrupts",
    "href": "labs.html#lab-5-interrupts",
    "title": "Labs",
    "section": "Lab 5: Interrupts",
    "text": "Lab 5: Interrupts"
  },
  {
    "objectID": "labs.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "href": "labs.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "title": "Labs",
    "section": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "text": "Lab 6: The Internet of Things and Serial Peripheral Interface"
  },
  {
    "objectID": "labs.html#lab-7-the-advanced-encryption-standard",
    "href": "labs.html#lab-7-the-advanced-encryption-standard",
    "title": "Labs",
    "section": "Lab 7: The Advanced Encryption Standard",
    "text": "Lab 7: The Advanced Encryption Standard"
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "The goal of this design is to practice multiplexing by designing a FPGA that can take two 4-bit inputs and 1) show their hexadecimal values with a dual 7-segment display and 2) show their sum in binary with 5 LEDs. The constraint is that only one 7-segment decoder module can be used for both digits on the display, resulting in the need of time-multiplexing."
  },
  {
    "objectID": "labs/lab2/lab2.html#introduction",
    "href": "labs/lab2/lab2.html#introduction",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "The goal of this design is to practice multiplexing by designing a FPGA that can take two 4-bit inputs and 1) show their hexadecimal values with a dual 7-segment display and 2) show their sum in binary with 5 LEDs. The constraint is that only one 7-segment decoder module can be used for both digits on the display, resulting in the need of time-multiplexing."
  },
  {
    "objectID": "labs/lab2/lab2.html#design",
    "href": "labs/lab2/lab2.html#design",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Design",
    "text": "Design\nThe top level design, lab2_gt, included three modules: the on-board high-speed oscillator (HSOSC) from the iCE40 UltraPlus primitive library, a clock divider to toggle or select between the digits shown on the display, and a 7-segment display decoder. The general idea of the design can be visualized with the block diagram below:\n\n\n\n\n\n\nFigure 1: Block diagram of the FPGA design\n\n\n\nThe clock divider, digitSelector, selects the digit which will be displayed on the dual 7-segment display with 60 Hz. The frequency was chosen such that the human eyes can not catch that the two digits are turning on and off, creating the illusion that both digits are always on at the same time. The module achieves such frequency by taking in a 48 MHz clock input clk given by the high-speed oscillator and using a counter incremented at each clock cycle to toggle the enabling signal for each digit at 60 Hz. It then outputs both enabling signals and the 4-bit binary of the digit with the enabled signal.\nThe 7-segment display decoder contains a set of combinational logic to translate a 4-bit binary signal into a single hexadecimal value. Each segment of the display is a LED controlled by an I/O pin from the UPduino board, and the shape of each hexadecimal value is unique. As per the constraint of this lab, this module is only used once and takes the 4-bit binary input of the selected digit given by digitSelector.\nIn terms of the circuitry design, the dual 7-segment display was externally accessed on a breadboard, with each of its two common anode connected to a 2N3906 PNP transistor to provide enough current. Other than the switch located on the PCB provided by the course, SW6, an external 4-input switch was also wired ono the breadboard. The switch on the PCB controls the left digit, whereas the one on the breadboard controls the right digit. The 5 LEDs for showing the sum are also connected on the breadboard. The schematics for the physical circuit design is shown in the following graph:\n\n\n\n\n\n\nFigure 2: Schematics of the circuit design\n\n\n\nFor the LEDs display is the sum, I chose to use red LEDs, whose forward voltage is normally around 1.6 V. Aiming for around 5 mA of current, which should provide enough brightness and is well below the maximum current of both the I/O pin of the UPduino (8 mA, found in section 4.17 of the datasheet) and the LED (20 mA conventionally), the resistor values for each LED can be calculated with:\n\\[\nR_{LED} = \\frac{3.3V - 1.6V}{0.005A} = 340 \\Omega\n\\]\nThe closest resistor I found was \\(330 \\Omega\\), which should not affect the current much.\nThe datasheet of the 2N3906 transistor shows that it has a base-emitter saturation voltage of 0.65 to 0.85 V when the current through the base is 1 mA. Aiming for a current slightly smaller than that to ensure safety, say 0.8 mA, the resistor value is:\n\\[\nR_{transistor} = \\frac{V_{PIN} - V_{BE,SAT}}{I_{transistor}} = \\frac{3.3V - 0.65V}{0.007A} \\approx 380 \\Omega\n\\]\nThe closest resistor I found was \\(390 \\Omega\\), which should not affect the current much.\nA resistor value of \\(220 \\Omega\\) are chosen considering the voltage and current across the LEDs. According to the dual 7-segment display datasheet, the voltage drop across the segments are about 1.8 V. The input voltage is the voltage given by the transistor, which is 2.6 V.Given that the collector-emitter saturation voltage was 0.4 V and aiming for approximately 5 mA across the LEDs of the segments, the resistor value is:\n\\[\nR_{seg} = \\frac{(V_{PIN} - V_{CE,SAT}) - V_{seg}}{I_{seg}} = \\frac{(3.3V - 0.4V) - 1.8V}{0.005A} = 220 \\Omega\n\\]"
  },
  {
    "objectID": "labs/lab2/lab2.html#testing-and-results",
    "href": "labs/lab2/lab2.html#testing-and-results",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Testing and Results",
    "text": "Testing and Results\nEach of the modules are testes with automated testbenches. The top level module was tested using a for-loop to stimulate all 256 (4-bit input s0 * 4-bit input s1), checking that the outputs for segments are correct when the enabling signal for each digit, disp0 and disp1, is on. The seven segment display decoder is identical to Lab 1, checking the combinational logic for all 16 possible inputs. The clock divider/digit selector checks that the enabling signals actually toggles and select the correct input for the 7-segment decoder after an expected amount of time.\nUsing Questa to simulate, the following figures show that All modules have successfully passed their testbench.\n\n\n\n\n\n\n\n\n\n\n\n(a) Waveform of the simulated top level module\n\n\n\n\n\n\n\n\n\n\n\n(b) Ending statement showing no errors for top level module\n\n\n\n\n\n\n\nFigure 3: Testbench results for the top level module lab2_gt\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) Waveform of the simulated segment display module\n\n\n\n\n\n\n\n\n\n\n\n(b) Ending statement showing no errors for segment display module\n\n\n\n\n\n\n\nFigure 4: Testbench results for the segment display module seven_seg_decoder\n\n\n\nAfter verifying the code with testbenches, the circuit which I built also has to be tested. There was no obvious blinking or toggling between the two digits, and output for both the display and the LEDs are correctly shown. Here is a picture of the complete device.\n\n\n\n\n\n\nFigure 5: Figure of full device working"
  },
  {
    "objectID": "labs/lab2/lab2.html#conclusion",
    "href": "labs/lab2/lab2.html#conclusion",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Conclusion",
    "text": "Conclusion\nIn this lab, I successfully designed and built an FPGA design that was able to correctly display hexadecimal values of two 4-bit binary input with only using one 7-segment decoder module. There was no observable blinking between the two digits. The binary sum of the two 4-bit inputs was also correctly shown with 5 LEDs. Therefore, I believe that my design for this lab meets all the requirements of this lab. This week, I spent 8 hours on the lab. Design did not take much time, but writing the testbenches and wiring up the circuits took a good amount of time. I hope to become more proficient in writing testbenches and be more aware of what should be tested in a design."
  },
  {
    "objectID": "labs/lab2/lab2.html#ai-prototype-summary",
    "href": "labs/lab2/lab2.html#ai-prototype-summary",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nFor this AI prototype, I used ChatGPT. When feeding it the first prompt, the resulted design was able to synthesize the first time, surprisingly. By looking at the code, this design seemed somewhat similar to what I did, and seemed like is functionable. However, this design did assume clk to be an external input, and kept the counter in the top level module instead of in an independent module. One thing that I like about its design was that it did include a parameter in the top level module, allowing easy changes to the frequency which the two digits toggle.\nFor the second prompt, since my counter module from Lab 1 was more than a clock divider and thus did not fit this purpose, I modified the prompt and asked it to:\n\nWrite SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder provided in the attached files and the HSOSC from the iCE40UP library.\n\nThe thinking time of this prompt was around 30 seconds, which was two times longer than the thinking time of privious prompt. When synthesizing it, it got this error:\n\nError 35901282 Synthesis ERROR &lt;35901282&gt; - c:/users/user/desktop/engr 155/lab2/e155_lab2/fpga/radiant_project/ai_2/source/impl_1/top.sv(67): loop count limit exceeded forever never breaks. VERI-1282 [top.sv:67]\n\nThis error came from the ifdef-elsif-else statement which this design provide. ChatGPT said the purpose of it was to include common ways to instantiate an on-chip oscillator and allows the user to choose which one by using the `ifdef. However, it was pretty redundant and got stuck on its approach of instantiate the clock if there is no on-chip oscillator:\n\nforever #10 clk_hf = ~clk_hf;\n\nIt also made the same mistake of using SB_HFOSC instead of HSOSC in Lab 1. After asking it to remove the ifdef-elsif-else statement and assuming that the osciallator will be instantiate with one method, the new design was able to synthesize, and seemed like would work fine when I read through it."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Georgia Tai is a junior engineering student at Harvey Mudd College (HMC) with an interest in computer engineering. Born and raised in Hsinchu, Taiwan, she developed a passion for electrical engineering. She is currently a Clay-Wolkin Fellow at HMC, working on an open-source verification suite for the RISC-V vector extension. Despite her current focus on verification, she also has a strong interest in hardware design and implementation. She hopes to continue developing her professional skills both inside and outside of this course."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Learning Goals\n\n\nMy learning goals and focuses for MicroPs.\n\n\n\n\n\nAug 29, 2025\n\n\nGeorgia Tai\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, a FPGA design was implemented to 1) blink an LED at 2.4Hz using an on-board high-speed oscillator, 2) control 2 LEDs with 4 switches, and 3) display a 4-digit binary input in hexadecimal using a 7-segment display. The logic of the second function, controlling LEDs with switches, is shown below:\n\nTable 1: Logic of switch-controlled LEDs\n\n\ns[3:2]\nLED[1]\ns[1:0]\nLED[0]\n\n\n\n\n00\n0\n00\n0\n\n\n01\n1\n01\n0\n\n\n10\n1\n10\n0\n\n\n11\n0\n11\n1"
  },
  {
    "objectID": "labs/lab1/lab1.html#introduction",
    "href": "labs/lab1/lab1.html#introduction",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, a FPGA design was implemented to 1) blink an LED at 2.4Hz using an on-board high-speed oscillator, 2) control 2 LEDs with 4 switches, and 3) display a 4-digit binary input in hexadecimal using a 7-segment display. The logic of the second function, controlling LEDs with switches, is shown below:\n\nTable 1: Logic of switch-controlled LEDs\n\n\ns[3:2]\nLED[1]\ns[1:0]\nLED[0]\n\n\n\n\n00\n0\n00\n0\n\n\n01\n1\n01\n0\n\n\n10\n1\n10\n0\n\n\n11\n0\n11\n1"
  },
  {
    "objectID": "labs/lab1/lab1.html#design",
    "href": "labs/lab1/lab1.html#design",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Design",
    "text": "Design\nThe top level design, lab1_gt, included three modules: the on-board high-speed oscillator (HSOSC) from the iCE40 UltraPlus primitive library, a counter for the blinking LED, and a 7-segment display decoder. The general idea of the design can be visualized with the block diagram below:\n\n\n\n\n\n\nFigure 1: Block diagram of the FPGA design\n\n\n\nThe 7-segment display decoder simply contained a set of combinational logic to translate a 4-bit binary signal into a single hexadecimal value. Each segment of the display is a LED controlled by an I/O pin from the UPduino board, and the shape of each hexadecimal value is unique, which will later be demonstrated in the Results section of this page.\nThe LED decoder included combinational logic to assign led[0] and led[1] using the inputs switches[3:0]. According to Table 1, led[1] can simply be assigned through a XOR gate and led[0] through an AND gate. The module also takes in a 24 MHz clock input clk given by the high-speed oscillator. It then uses a counter incremented at each clock cycle to toggle led[2] every 5 million cycles, allowing the LED to blink at 2.4 Hz.\nOn the physical side of design, the 7-segment display was externally accessed on a breadboard. The switch used for inputs and the LEDs are soldered on the board provided by the course. The schematics for the physical circuit design is shown in the following graph:\n\n\n\n\n\n\nFigure 2: Schematics of the circuit design\n\n\n\nA resistor value of \\(220 \\Omega\\) are chosen considering the voltage and current across the LEDs. According to the 7-segment display datasheet, the ideal current across the LEDs on the display should be 20mA. Given that \\(V = IR\\), a driving voltage of \\(3.3V\\) and a voltage drop of \\(2.1V\\) across red LEDs,\n\\[\nR = \\frac{3.3V - 2.1V}{0.02A} = 60 \\Omega\n\\]\nSince \\(220 \\Omega &gt; 60 \\Omega\\), a \\(220 \\Omega\\) resistor would allow the current to stay within the safety range and was tested to provide enough brightness."
  },
  {
    "objectID": "labs/lab1/lab1.html#results",
    "href": "labs/lab1/lab1.html#results",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Testing and Results",
    "text": "Testing and Results\nAt the beginning of the lab, we first had to solder the components onto the board. After soldering the board, I tested it with the Radiant tutorial provided on the course website and verified that the componenets are working as expected.\nThe led2_counter module, which is used to make one of the LEDs blink at 2.4 Hz, is hard to test through a testbench due to its use of high-frequency oscillators. Alternatively, we can directly verify its functionality using an oscilloscope to measure the frequency of the blinking LED. As shown in Figure 3, led[2] is indeed blinking at approximately 2.4 Hz, fitting the one of the requirements of the lab.\n\n\n\n\n\n\nFigure 3: Oscilloscope result of frequency of blinking LED, led[2]\n\n\n\nSince the inputs were only four switches, or 16 combinations, the other two self-designed modules, lab1_gt and seven_seg_decoder, can be easily tested through automated testbenches. I wrote two testbenches, one for the top level module and the other for the seven segment display decoder, then created TV-file test vectors accordingly. Using Questa to simulate, the following figures show that both modules have successfully passed their testbench. Note that the led[2] is previously tested and can be neglected here.\n\n\n\n\n\n\n\n\n\n\n\n(a) Waveform of the simulated top level module\n\n\n\n\n\n\n\n\n\n\n\n(b) Ending statement showing no errors for top level module\n\n\n\n\n\n\n\nFigure 4: Testbench results for the top level module lab1_gt\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) Waveform of the simulated segment display module\n\n\n\n\n\n\n\n\n\n\n\n(b) Ending statement showing no errors for segment display module\n\n\n\n\n\n\n\nFigure 5: Testbench results for the segment display module seven_seg_decoder\n\n\n\nAfter verifying the code with testbenches, the circuit which I built also has to be tested. The following video shows a completely demo of me trying all 16 combination of switch inputs on my system. As shown in the video, each combination of switches, relating to a single hexadecimal digit, has a unique pattern and was able to turn on successfully. On top of that, the three LEDs close to the left-bottom corner of the ribbon cable performed as expected. The two non-blinking LEDs, with the right one being led[0], worked according to the described logic of led[1] and led[0]. Although this video was sped up by 1.5 times, the blinking LED led[2] was blinking at the expected frequency of 2.4 Hz, as previously verified."
  },
  {
    "objectID": "labs/lab1/lab1.html#conclusion",
    "href": "labs/lab1/lab1.html#conclusion",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Conclusion",
    "text": "Conclusion\nIn this lab, I successfully designed and built a seven-segment display, which was able to translate a 4-bit input given by a set of switches into unique single digit hexadecimal number. I was also able to create the LEDs as the lab required. Therefore, I believe that my design for this lab meets all the requirements of this lab. This week, I spent 15 hours on the lab. A lot of time was put into installing things and getting familiarized with the apps and environment. Hopefully, the whole lab flow would be easier in the future, and I can work more efficiently, focusing on designing and verifying the systems."
  },
  {
    "objectID": "labs/lab1/lab1.html#ai-prototype-summary",
    "href": "labs/lab1/lab1.html#ai-prototype-summary",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nFor the AI prototype, I chose to use the default model of ChatGPT. After putting in the promopt, it returned its first code which had this error and caused systhesis to fail:\nERROR &lt;35901063&gt; - c:/users/user/desktop/e155_lab1/fpga/radiant_project/ai/source/impl_1/top.sv(17): instantiating unknown module SB_HFOSC. VERI-1063 [top.sv:17]\nLooking at this error, I noticed that it was using a different module name compared to what we used, HSOSC, but I wasn’t sure if this module specified by chatGPT was actually available. However, I decided to simply throw in the error. ChatGPT insisted that SB_HFOSC was the right module, and repeatedly asked me to check my settings. At some point, it even threw in the idea of declaring the module as a black box with (* blackbox *), whicih also caused other trivial issues and was still unable to solve the root cause. Knowing that this is a rabbit hole, I decided to search up SB_HFOSC online and found the following information in the iCE40 Oscillator Usage Guide:\n\n1.1. Key Features The following oscillators are available to iCEcube2 users: SB_LFOSC – Low Frequency Oscillator, SB_HFOSC – High Frequency Oscillator with output divider The following oscillators are available to Lattice Radiant Software users: LSOSC – Low Frequency Oscillator, HSOSC – High Frequency Oscillator with output divider\n\nI gave this information back to ChatGPT, and it then returned another draft of the module, which passed systhesis this time.\nOverall, I would rate the experience for coding with ChatGPT a 5.5/10. It did help explaining the calculations and also drafting the code, but I feel never really felt confident in the things it produced and had to also do a self mental check. Personally, I feel more confident in debugging and finding the non-reasonable parts from a piece of code than writing one from scratch. In this case, for example, I was able to find the unfamiliar module from ChatGPT’s code and also think of ways to make the code cleaner, but that was also partially because I had prior knowledge to the prompt. This time, ChatGPT providing a somewhat feasible draft did help improve the work efficiency, thus I rated it an above average score. That being said, the quality of it’s code is not always consistent, and I would most likely suggest one to be fairly confident in the topic of the prompt before asking a LLM to code from scratch."
  },
  {
    "objectID": "posts/week0_learningGoals.html",
    "href": "posts/week0_learningGoals.html",
    "title": "Learning Goals",
    "section": "",
    "text": "I think this course will help me develop both hard and soft skills over the semester, and I’m excited to dive deeper into learning about microprocessors and digital systems.\nE85 really stood out as a valuable class to me because I had a lot of fun designing a multicycle RISC-V processor. Having focused on verification through research over the past summer, I’m eager to return to the design side and strengthen my skills in RTL design. In particular, I want to deepen my fluency in SystemVerilog, focusing on writing more efficient and clean code. As someone who hopes to pursue a career in hardware engineering, I see this as an important skill to have, allowing me to build a stronger foundation in design.\nOn the other hand, having heard that this class has a heavy workload, I also want to improve my time management and efficiency. While I feel fairly confident in learning through hands-on project, I want to push myself to work more systematically and efficiently through the labs and final project. I’m also looking forward to developing my technical writing skills, which I believe this course will give me the chance to by approaching projects more systematically and thoughtfully."
  }
]